apply plugin: "com.android.application"
apply plugin: "org.jetbrains.kotlin.android"
apply plugin: "com.facebook.react"

def projectRoot = rootDir.getAbsoluteFile().getParentFile().getAbsolutePath()

static def versionToNumber(major, minor, patch) {
  return patch * 100 + minor * 10000 + major * 1000000
}

def getRNVersion() {
  def version = providers.exec {
    workingDir(projectDir)
    commandLine("node", "-e", "console.log(require('react-native/package.json').version);")
  }.standardOutput.asText.get().trim()

  def coreVersion = version.split("-")[0]
  def (major, minor, patch) = coreVersion.tokenize('.').collect { it.toInteger() }

  return versionToNumber(major, minor, patch)
}
def rnVersion = getRNVersion()

/**
 * React Native configuration block (без file() вызовов)
 */
react {
    // Только базовые параметры — без file()
    bundleCommand = "export:embed"

    if (rnVersion >= versionToNumber(0, 75, 0)) {
        autolinkLibrariesWithApp()
    }
}

/**
 * Безопасно определяем entryFile после react {}.
 * Это полностью исключает падение "path may not be null or empty string"
 */
def resolvedEntryPath = ""
try {
    resolvedEntryPath = ["node", "-e", "require('expo/scripts/resolveAppEntry')", projectRoot, "android", "absolute"]
        .execute(null, rootDir)
        .text
        .trim()
} catch (Exception ignored) {
    println "[WARN] Expo entry file detection failed"
}

if (!resolvedEntryPath || resolvedEntryPath.isEmpty()) {
    println "[WARN] Expo entry file not resolved — fallback to index.js"
    resolvedEntryPath = "$rootDir/../index.js"
}
println "[INFO] Using entry file: $resolvedEntryPath"

/**
 * Apply the entryFile directly via Gradle property.
 */
project.ext.set("react", [
    entryFile: resolvedEntryPath
])

/**
 * Global flags and defaults.
 */
def enableProguardInReleaseBuilds = (findProperty('android.enableProguardInReleaseBuilds') ?: false).toBoolean()
def jscFlavor = 'org.webkit:android-jsc:+'

android {
    ndkVersion rootProject.ext.ndkVersion
    buildToolsVersion rootProject.ext.buildToolsVersion
    compileSdk rootProject.ext.compileSdkVersion

    namespace 'com.yourcompany.barista'

    defaultConfig {
        applicationId 'com.yourcompany.barista'
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0.0"
    }

    /**
     * ✅ Safe signing configuration (works locally and in CI)
     */
    signingConfigs {
        debug {
            storeFile file('debug.keystore')
            storePassword 'android'
            keyAlias 'androiddebugkey'
            keyPassword 'android'
        }

        release {
            def storeFilePath = System.getenv("MYAPP_UPLOAD_STORE_FILE") ?: project.findProperty("MYAPP_UPLOAD_STORE_FILE")
            if (storeFilePath && !storeFilePath.trim().isEmpty()) {
                storeFile file(storeFilePath)
            } else {
                storeFile file("$rootDir/app/my-release-key.jks")
            }

            storePassword System.getenv("MYAPP_UPLOAD_STORE_PASSWORD") ?: project.findProperty("MYAPP_UPLOAD_STORE_PASSWORD")
            keyAlias System.getenv("MYAPP_UPLOAD_KEY_ALIAS") ?: project.findProperty("MYAPP_UPLOAD_KEY_ALIAS")
            keyPassword System.getenv("MYAPP_UPLOAD_KEY_PASSWORD") ?: project.findProperty("MYAPP_UPLOAD_KEY_PASSWORD")
        }
    }

    buildTypes {
        debug {
            signingConfig signingConfigs.debug
        }
        release {
            signingConfig signingConfigs.release
            shrinkResources (findProperty('android.enableShrinkResourcesInReleaseBuilds')?.toBoolean() ?: false)
            minifyEnabled enableProguardInReleaseBuilds
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            crunchPngs (findProperty('android.enablePngCrunchInReleaseBuilds')?.toBoolean() ?: true)
        }
    }

    packagingOptions {
        jniLibs {
            useLegacyPackaging (findProperty('expo.useLegacyPackaging')?.toBoolean() ?: false)
        }
    }
}

/**
 * Merge static gradle.properties values (e.g., pickFirsts, excludes, etc.)
 */
["pickFirsts", "excludes", "merges", "doNotStrip"].each { prop ->
    def options = (findProperty("android.packagingOptions.$prop") ?: "").split(",")
    for (i in 0..<options.size()) options[i] = options[i].trim()
    options -= ""

    if (options.length > 0) {
        println "android.packagingOptions.$prop += $options ($options.length)"
        options.each {
            android.packagingOptions[prop] += it
        }
    }
}

dependencies {
    implementation("com.facebook.react:react-android")

    def isGifEnabled = (findProperty('expo.gif.enabled') ?: "") == "true"
    def isWebpEnabled = (findProperty('expo.webp.enabled') ?: "") == "true"
    def isWebpAnimatedEnabled = (findProperty('expo.webp.animated') ?: "") == "true"

    if (isGifEnabled) {
        implementation("com.facebook.fresco:animated-gif:${reactAndroidLibs.versions.fresco.get()}")
    }

    if (isWebpEnabled) {
        implementation("com.facebook.fresco:webpsupport:${reactAndroidLibs.versions.fresco.get()}")
        if (isWebpAnimatedEnabled) {
            implementation("com.facebook.fresco:animated-webp:${reactAndroidLibs.versions.fresco.get()}")
        }
    }

    if (hermesEnabled.toBoolean()) {
        implementation("com.facebook.react:hermes-android")
    } else {
        implementation jscFlavor
    }
}

/**
 * Apply native modules for RN < 0.75
 */
if (rnVersion < versionToNumber(0, 75, 0)) {
    apply from: new File(
        ["node", "--print", "require.resolve('@react-native-community/cli-platform-android/package.json', { paths: [require.resolve('react-native/package.json')] })"]
            .execute(null, rootDir)
            .text
            .trim(),
        "../native_modules.gradle"
    )
    applyNativeModulesAppBuildGradle(project)
}
